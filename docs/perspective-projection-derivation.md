# 透视投影矩阵推导（右手坐标系）

## 坐标系约定

在**右手坐标系**的观察空间中：
- **+X** 指向右侧
- **+Y** 指向上方
- **-Z** 指向屏幕内部（观察方向）
- 摄像机沿着**负Z轴**观察

## 透视投影基础

### 1. 基本透视除法

对于观察空间中的点 P(x, y, z)，透视投影使用相似三角形原理将其映射到屏幕空间：

```
x' = (n * x) / (-z)
y' = (n * y) / (-z)
```

其中：
- `n` 是近平面距离（正值）
- `-z` 用于除法，因为我们沿着-Z轴观察
- `x'`, `y'` 是投影到近平面上的坐标

### 2. 视锥体参数

视锥体由以下参数定义：
- **n**: 近平面距离（正值）
- **f**: 远平面距离（正值，f > n）
- **fov**: 视场角（垂直方向）
- **aspect**: 宽高比（宽度 / 高度）

从视场角和宽高比可以推导出：
- **t** (顶部): `n * tan(fov / 2)`
- **b** (底部): `-t`
- **r** (右侧): `t * aspect`
- **l** (左侧): `-r`

## 逐步推导

### 步骤 1: 将 X 和 Y 归一化到 [-1, 1]

#### 为什么需要归一化到 [-1, 1]？

图形渲染管线需要一个**标准化的坐标空间**，称为**归一化设备坐标 (NDC, Normalized Device Coordinates)**。原因如下：

1. **统一处理**：不同的视锥体有不同的宽度和高度，归一化后所有视锥体都映射到相同的立方体 [-1, 1]³
2. **硬件标准**：GPU 硬件期望接收 NDC 坐标进行光栅化
3. **裁剪简化**：在 [-1, 1] 范围内进行裁剪测试非常简单（只需检查坐标是否在 ±1 之间）
4. **分辨率无关**：NDC 与屏幕分辨率无关，后续再映射到实际像素坐标

#### 线性映射公式推导

要将 x 从 [l, r] 线性映射到 [-1, 1]，我们需要一个线性函数：

```
x_ndc = A * x' + B
```

**约束条件：**
- 当 x' = l 时，x_ndc = -1
- 当 x' = r 时，x_ndc = 1

**求解系数 A 和 B：**

从约束条件得到方程组：
```
-1 = A * l + B  ... (1)
 1 = A * r + B  ... (2)
```

方程 (2) - 方程 (1)：
```
1 - (-1) = A * r - A * l
2 = A * (r - l)
A = 2 / (r - l)
```

将 A 代入方程 (1)：
```
-1 = (2 / (r - l)) * l + B
B = -1 - 2l / (r - l)
B = -(r - l) / (r - l) - 2l / (r - l)
B = -(r - l + 2l) / (r - l)
B = -(r + l) / (r - l)
```

**最终映射公式：**
```
x_ndc = (2 / (r - l)) * x' - (r + l) / (r - l)
      = (2 * x') / (r - l) - (r + l) / (r - l)
```

**代入透视投影后的 x'：**

由于 x' = (n * x) / (-z)，代入得：
```
x_ndc = (2 * n * x) / ((-z) * (r - l)) - (r + l) / (r - l)
```

#### Y 坐标的映射

同理，将 y 从 [b, t] 映射到 [-1, 1]：
```
y_ndc = (2 * y') / (t - b) - (t + b) / (t - b)
      = (2 * n * y) / ((-z) * (t - b)) - (t + b) / (t - b)
```

#### 几何意义

这个映射过程可以理解为：

1. **缩放**：系数 `2 / (r - l)` 将 [l, r] 的宽度缩放到 2（[-1, 1] 的宽度）
2. **平移**：减去 `(r + l) / (r - l)` 将中心点从 `(r + l) / 2` 移动到 0

**特殊情况：对称视锥体**

当 l = -r 时（左右对称）：
- (r + l) / (r - l) = 0 / (2r) = 0
- 公式简化为：x_ndc = (2 * x') / (2r) = x' / r

这意味着对称视锥体不需要平移，只需缩放！

### 步骤 2: 将 Z 映射到 NDC 范围

对于 OpenGL，我们将 z 从 [-n, -f] 映射到 [-1, 1]：

我们需要一个线性变换：
```
z_ndc = A * z + B
```

约束条件：
- 当 z = -n 时: z_ndc = -1
- 当 z = -f 时: z_ndc = 1

求解：
```
-1 = A * (-n) + B  →  -1 = -A*n + B
 1 = A * (-f) + B  →   1 = -A*f + B

相减得: -2 = -A*n + A*f = A(f - n)
因此: A = -2 / (f - n)

从第一个方程: B = -1 + A*n = -1 - 2n/(f - n) = -(f + n)/(f - n)
```

所以：
```
z_ndc = (-2 / (f - n)) * z - (f + n) / (f - n)
```

透视除法后（除以 -z）：
```
z_ndc = (2*n / (f - n)) + (f + n) / ((-z) * (f - n))
```

### 步骤 3: 构造矩阵

在齐次坐标中，我们需要：
```
[x']     [x_ndc * w]     [M00  M01  M02  M03] [x]
[y']  =  [y_ndc * w]  =  [M10  M11  M12  M13] [y]
[z']     [z_ndc * w]     [M20  M21  M22  M23] [z]
[w']     [w]             [M30  M31  M32  M33] [1]
```

其中 w = -z（用于透视除法）。

根据我们的推导：

**第 0 行（X 分量）：**
```
x_clip = (2*n / (r - l)) * x + ((r + l) / (r - l)) * z
```

**第 1 行（Y 分量）：**
```
y_clip = (2*n / (t - b)) * y + ((t + b) / (t - b)) * z
```

**第 2 行（Z 分量）：**
```
z_clip = (-(f + n) / (f - n)) * z + (-2*f*n / (f - n))
```

**第 3 行（W 分量）：**
```
w_clip = -z
```

### 步骤 4: 最终投影矩阵

```
P = [2n/(r-l)      0         (r+l)/(r-l)      0      ]
    [   0       2n/(t-b)     (t+b)/(t-b)      0      ]
    [   0          0        -(f+n)/(f-n)  -2fn/(f-n) ]
    [   0          0            -1            0      ]
```

### 步骤 5: 对称视锥体（常见情况）

对于对称视锥体，其中 l = -r 且 b = -t：
- (r + l) / (r - l) = 0
- (t + b) / (t - b) = 0

矩阵简化为：

```
P = [2n/(r-l)      0            0            0      ]
    [   0       2n/(t-b)        0            0      ]
    [   0          0        -(f+n)/(f-n)  -2fn/(f-n) ]
    [   0          0            -1            0      ]
```

即：
```
P = [n/r         0            0            0      ]
    [ 0         n/t           0            0      ]
    [ 0          0        -(f+n)/(f-n)  -2fn/(f-n) ]
    [ 0          0            -1            0      ]
```

### 步骤 6: 使用视场角和宽高比

给定：
- `t = n * tan(fov / 2)`
- `r = t * aspect`

我们得到：
```
n/r = 1 / (aspect * tan(fov/2))
n/t = 1 / tan(fov/2) = cot(fov/2)
```

最终矩阵：
```
P = [1/(aspect*tan(fov/2))        0                0                0        ]
    [         0            1/tan(fov/2)            0                0        ]
    [         0                   0          -(f+n)/(f-n)    -2fn/(f-n)     ]
    [         0                   0               -1               0        ]
```

## 关键特性

1. **透视除法**：第 3 行第 2 列的 -1 使得 w' = -z，从而实现透视除法
2. **深度缓冲精度**：非线性的 Z 映射在近平面附近提供更高的精度
3. **右手坐标系**：负号保持了右手坐标系的特性
4. **NDC 范围**：将 x, y, z 映射到 [-1, 1]（OpenGL 约定）

## 实现示例

```typescript
function perspectiveMatrix(
  fov: number,      // 垂直视场角（弧度）
  aspect: number,   // 宽高比（宽度 / 高度）
  near: number,     // 近平面距离
  far: number       // 远平面距离
): mat4 {
  const f = 1.0 / Math.tan(fov / 2);
  const nf = 1.0 / (near - far);
  
  return [
    f / aspect, 0,  0,                        0,
    0,          f,  0,                        0,
    0,          0,  (far + near) * nf,      -1,
    0,          0,  2 * far * near * nf,     0
  ];
}
```

注意：这假设列主序矩阵存储（OpenGL 约定）。

## 与左手坐标系的比较

在**左手坐标系**中（如 DirectX 默认）：
- +Z 指向屏幕内部
- 投影矩阵在位置 [3][2] 处为 +1 而不是 -1
- Z 从 [n, f] 映射到 [0, 1]（DirectX）或 [-1, 1]（OpenGL）

右手坐标系在图形 API（如 OpenGL）中更常见，并且更符合数学约定。

## 详细推导说明

### 为什么 w_clip = -z？

在透视投影中，我们需要将 3D 点投影到 2D 平面上。关键在于**透视除法**：

```
x_ndc = x_clip / w_clip
y_ndc = y_clip / w_clip
z_ndc = z_clip / w_clip
```

由于透视效果要求离相机越远的物体看起来越小，我们需要用深度值来除坐标。在右手坐标系中，相机看向 -Z 方向，所以深度值是 -z（负的 z 坐标）。因此设置 w_clip = -z。

### Z 分量的非线性映射

Z 分量的映射公式：
```
z_clip = (-(f + n) / (f - n)) * z + (-2*f*n / (f - n))
```

透视除法后：
```
z_ndc = z_clip / w_clip = z_clip / (-z)
      = ((f + n) / (f - n)) + (2*f*n / (f - n)) / z
```

这是一个**双曲线函数**，具有以下特点：
- 在近平面附近变化快（高精度）
- 在远平面附近变化慢（低精度）
- 这种分布符合人眼对深度的感知特性

### 矩阵第三列的作用

注意矩阵的第三列（索引为 2）：
```
[(r+l)/(r-l)  ]
[(t+b)/(t-b)  ]
[-(f+n)/(f-n) ]
[    -1       ]
```

这一列与输入的 z 坐标相乘，产生：
- x_clip 的偏移（处理非对称视锥体）
- y_clip 的偏移（处理非对称视锥体）
- z_clip 的线性部分
- w_clip = -z（实现透视除法）

对于对称视锥体，前两项为 0，简化了计算。

## 常见问题

### Q1: 为什么近平面和远平面都是正值？

在右手坐标系中，虽然相机看向 -Z 方向，但我们用正值表示距离。实际的平面位置是 z = -n 和 z = -f。

### Q2: 如何处理无限远平面？

当 f → ∞ 时，矩阵简化为：
```
P = [1/(aspect*tan(fov/2))    0           0        0  ]
    [         0        1/tan(fov/2)       0        0  ]
    [         0               0          -1       -2n ]
    [         0               0          -1        0  ]
```

### Q3: 列主序 vs 行主序？

上述矩阵假设**列主序**存储（OpenGL 风格）。如果使用**行主序**（DirectX 风格），需要转置矩阵，并且乘法顺序变为 `v * M` 而不是 `M * v`。

## 总结

透视投影矩阵的核心思想：
1. 使用相似三角形原理实现透视缩放
2. 通过齐次坐标的 w 分量实现透视除法
3. 将视锥体映射到标准化设备坐标 (NDC) 立方体
4. 使用非线性 Z 映射优化深度缓冲精度

理解这个推导过程对于图形编程、调试渲染问题和优化性能都非常重要。
